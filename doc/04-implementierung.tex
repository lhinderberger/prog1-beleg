\section{Implementierung}
Einige technische Fragen klärten sich erst im Verlaufe des Feinentwurfes bzw. der Implementierung.
Auf sie wird im Folgenden näher eingegangen

\subsection{Fehlerbehandlung}
Während in höheren Programmiersprachen wie Java oder C\# die Fehlerbehandlung via Exceptions standardisiert, stabil
und somit naheliegend ist, kann dies für C++ nicht uneingeschränkt\footnote{Zwar existiert für C++ eine Fehlerbehandlung
via Exceptions, allerdings ist diese für Bibliotheken nicht ohne Einschränkungen praktikabel, da Schnittstelle und
Verhalten von C++-Exceptions nicht im Standard festgeschrieben und somit vom verwendeten Compiler abhängig sind.
Da auch C++-Binärschnittstellen uneinheitlich sind, werden in der Praxis meist auch in C++ geschriebene
Bibliotheken in C-Wrapper verpackt.} und für C-Programme überhaupt nicht behauptet werden.

In der Praxis trifft man bei der Fehlerbehandlung in C-Programmen und -Bibliotheken auf verschiedenste Lösungen, vom
simplem Programmabbruch, über die Prüfung von Rückgabewerten bis hin zu Nachbauten von Exception-Mechanismen.
Während letzteres zwar großen Charme hat, ist dies für Bibliotheken -- besonders wenn diese in Binärform vorliegen
sollen -- aufgrund technischer Restriktionen (mangelnde Kompatiblität zwischen unterschiedlichen
longjmp-Implementierungen) nicht praktikabel. Gleiches gilt aus Gründen der Nutzerfreundlichkeit für den simplen
Programmabbruch.

Ich habe mich daher für die Fehlerbehandlung an der C-Standardbibliothek orientiert, welche die Rückgabe eines
Fehlerwerts, das Setzen einer \lstinline{errno}-Variablen und das Bereitstellen eines vertiefenden Error-Strings vorsieht.
Eventuellen Implementierungen von Drittparteien wird hierbei über einen privaten Header das eigene Setzen eines
dynamischen Error Strings für den \lstinline{pb_errno}-Wert \lstinline{PB_E_CUSTOM} ermöglicht.

Während der Implementierung bin ich auf das Problem gestoßen, dass, wenn die Fehlervariable nicht manuell ausgelesen und
gelöscht wird, nachfolgende Funktionsaufrufe fälschlicherweise Fehlerbedingungen signalisieren könnten. Um diese
Sorgfaltspflicht also nicht der aufrufenden Software zu übertragen, habe ich mich dafür entschieden, in allen Funktionen,
die eine Fehlerbedingung erzeugen können, zunächst die Fehlervariable zu löschen.

\subsection{Tests}
Eine möglichst hohe Testabdeckung der Kernbibliothek wurde angestrebt und die Entwicklung nach der
Test-Driven-Development-Methode erprobt.

Hierbei wurde auf Tests zu allen Funktionen verzichtet, welche lediglich einen Wrapper um SQLite darstellen, da die
Funktionalität von externen Bibliotheken üblicherweise nicht durch eigene Programmtests zu verifizieren ist, sondern
bereits durch die Programmtests der externen Bibliothek verifiziert wurde. Stattdessen halte ich mich hierbei an deren
Schnittstellenbeschreibung.
Für den hypothetischen Fall, dass das Datenbank-Backend ausgetauscht wird (weswegen überhaupt erst ein Wrapper
geschrieben wurde) wären dann allerdings Tests angebracht, um sicherzustellen, dass sich das neue Datenbank-Backend im
Wrapper identisch zu SQLite verhält.

Meine Erfahrungen mit der Methode des Test Driven Development waren höchst positiv. So konnten während der Entwicklung
und noch vor Einsatz der Datenabstraktionsschicht bereits eine ganze Reihe an kritischen Fehler entdeckt und behoben werden.
Außerdem ist durch die Unit Tests sehr verlässlich eine gewisse Grundfunktionalität für typische Szenarien gesichert.

Eine Erweiterung um Spezialfälle, automatisierte Testfallgenerierung (sogenanntes ``Fuzzy Testing'') oder die automatische
Sicherstellung der Einhaltung zu definierender Betriebsgrenzen der Software (z.B. maximale Anzahl erfassbarer Datensätze)
wäre denkbar und für den praktischen Einsatz ratsam.

Hierbei ist besonders hervorzuheben, dass die geschriebenen Softwaretests keine ``Wegwerfprodukte'' sind, sondern auf
Dauer Bestandteil der Qualitätssicherungskette der Software bleiben und diese mit jedem geschriebenen Softwaretest
verbessert wird. Hierbei ist natürlich die Les- und somit Wartbarkeit der Softwaretests besonders zu beachten, da dies
andernfalls möglicherweise den langfristigen Projekterfolg gefährden kann.

\subsection{Abfrageschnittstelle}
TODO