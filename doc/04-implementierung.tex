\section{Implementierung}
Einige technische Fragen klärten sich erst im Verlaufe des Feinentwurfes bzw. der Implementierung.
Auf sie wird im Folgenden näher eingegangen

\subsection{Fehlerbehandlung}
Während in höheren Programmiersprachen wie Java oder C\# die Fehlerbehandlung via Exceptions standardisiert, stabil
und somit naheliegend ist, kann dies für C++ nicht uneingeschränkt\footnote{Zwar existiert für C++ eine Fehlerbehandlung
via Exceptions, allerdings ist diese für Bibliotheken nicht ohne Einschränkungen praktikabel, da Schnittstelle und
Verhalten von C++-Exceptions nicht im Standard festgeschrieben und somit vom verwendeten Compiler abhängig sind.
Da auch C++-Binärschnittstellen uneinheitlich sind, werden in der Praxis meist auch in C++ geschriebene
Bibliotheken in C-Wrapper verpackt.} und für C-Programme überhaupt nicht behauptet werden.

In der Praxis trifft man bei der Fehlerbehandlung in C-Programmen und -Bibliotheken auf verschiedenste Lösungen, vom
simplem Programmabbruch, über die Prüfung von Rückgabewerten bis hin zu Nachbauten von Exception-Mechanismen.
Während letzteres zwar großen Charme hat, ist dies für Bibliotheken -- besonders wenn diese in Binärform vorliegen
sollen -- aufgrund technischer Restriktionen (mangelnde Kompatiblität zwischen unterschiedlichen
longjmp-Implementierungen) nicht praktikabel. Gleiches gilt aus Gründen der Nutzerfreundlichkeit für den simplen
Programmabbruch.

Ich habe mich daher für die Fehlerbehandlung an der C-Standardbibliothek orientiert, welche die Rückgabe eines
Fehlerwerts, das Setzen einer \lstinline{errno}-Variablen und das Bereitstellen eines vertiefenden Error-Strings vorsieht.
Eventuellen Implementierungen von Drittparteien wird hierbei über einen privaten Header das eigene Setzen eines
dynamischen Error Strings für den \lstinline{pb_errno}-Wert \lstinline{PB_E_CUSTOM} ermöglicht.

\subsection{Tests}
Eine möglichst hohe Testabdeckung der Kernbibliothek wurde angestrebt und die Entwicklung nach der
Test-Driven-Development-Methode erprobt.

Hierbei wurde auf Tests zu allen Funktionen verzichtet, welche lediglich einen Wrapper um SQLite darstellen, da die
Funktionalität von externen Bibliotheken üblicherweise nicht durch eigene Programmtests zu verifizieren ist, sondern
bereits durch die Programmtests der externen Bibliothek verifiziert wurde. Stattdessen halte ich mich hierbei an deren
Schnittstellenbeschreibung.
Für den hypothetischen Fall, dass das Datenbank-Backend ausgetauscht wird (weswegen überhaupt erst ein Wrapper
geschrieben wurde) wären dann allerdings Tests angebracht, um sicherzustellen, dass sich das neue Datenbank-Backend im
Wrapper identisch zu SQLite verhält.

\subsection{Abfrageschnittstelle}
TODO